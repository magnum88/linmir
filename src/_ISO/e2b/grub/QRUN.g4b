!BAT
# GRUB4DOS simple batch script.
#
# Use a batch script to run a file depending on it's extension
#
# /QRUN.g4b /somedir/somefile
#
# /QRUN.g4b override.isogrub /somedir/somefile.iso
#
# This script requires GRUB4DOS 2010-12-14 or later.
# some functions require /xxx/memdisk and /xxx/firadisk.gz
#
# History
# v2 - added %2 for override of extension type
# 1.17 - .isoDOS added
# 1.18 - .isoDOS01 added
# 1.29 - .isofira01, .isomemF01 added
# 1.30 - .isopup added, .isoWB added
# 1.32 - .isoEFI added
# 1.34 - .isoPTN added (backup at LBA30 and 60)
# 1.37 - .imgPTNA and lba and 23 variants added
# 1.40 - Auxillary file mapped to (hd0,2) when .imgPTN file is run (auxilliary file must have no extension)
# 1.42a - add CONTIG.ISO to make ISO files contiguous  (1.42a bugfix if o=using forceiso)
# 1.51 - .imgPTN is now equivalent to .imgPTNLBA , for old .imgPTN use .imgPTNna  (non-active)
# 1.54 - bugfix for force extension, .IMArw, .IMAnomem added for rw access to floppy images
# 1.56 - iso64 options added
# 1.58 - errorcheck off added around map (hd1) swap so runs even if no system hdd, few other changes
# 1.61 - added .isonousb and .imgnousb
# 1.62 - add .dmg and .dmgHFS and .HFSPTN, if "pwd" in file extension then ask for password
# 1.63 - 2015-03-25 add .isomacpup and .haiku and .imgPTNA5 for FreeBSD, auto-suggest ISO extension
# 1.69 - 2015-06-02 support .wim, .vhd now for NT6 booting using NTBOOT, .vhdboot uses grub4dos to boot
# 1.72 - 2015-09-02 CRC = SHIFT+CTRL
# 1.73 - 2015-10-11 If .imgPTN and ptn#2=Type21 then leave ptn#2 alone (don't remove)
# 1.74 - 2015-11-06 .vhdfira added and .vhdboot modified to add firadisk, imghd modified to boot ntldr/bootmgr first
# 1.75 - 2015-11-12 .isoBF added, .vhdgrldr, fix various .imgPTNxxxx label typos in 1.74
# 1.76 - 2015-12-14 .isoBF bugfix, add .imghdlinux for type 83 disk images - e.g. wipemydisks1.1.img
# 1.77 - 2016-01-18 .imgptnauto added to type 21 check, check .imgPTN is before . and warn user
# 1.78 - 2016-02-06 .imafdhdd0 added, use E2BDEV wherever possible, remove old xxx64xx extensions, add .isoHW. .KRN, .LKRN extensions, AUTO suffix can be used on any .imgPTNxxx extension
# 1.79 - 2016-03-27 improve error handling using :waitexit
# 1.81 - 2016-06-11 Use call echo -e %emsg%  (else %ISOC% is displayed on screen), fix .ISOPE, check bootmgr version, iISOPECD and .ISOPE01CD added
# 1.83 - 2016-08-17 .imz not supported by grub4dos
# 1.88 - 2016-12-26 fix .isofira to load iso as CD

# Max no lines = 2048 in a batch file, Max. no. labels in  a batch file = 128, file must start with !BAT on first line.
#=============================================================================

debug 1
errorcheck on
checkrange 20131130:-1 read 0x8278 > nul || echo Old grub4dos version! && call :waitexit 5 && exit 1

# get special keys - e.g. SHIFT, CTRL, etc. into n for use later
set n=
/%grub%/bios int=0x16 eax=0x00000200 > (md)0x300+1
cat --skip=12 --length=2 (md)0x300+1 | set /a n=0x > nul
# bits in n = LShift=01, RShift=02,CTRL=04,ALT=08,SCROLL=10,NUM=20,CAPS=40,INS=80

debug 0
delmod -l getstr.g4b || insmod /%grub%/getstr.g4b
debug 1

# if 2nd param exists, then first is dummy filename+extension used for override - e.g. QRUN.g4b  junk.isowinvh /_ISO/MAIMENU/hirens.iso
set ISOC=
set ISOC=%1
set JE=%~x1
if not "%2"=="" shift && set ISOC=%2 && set JE=%~x1

# ISOC must have device name, add () if not present
if not "%ISOC:~0,1%"=="(" set ISOC=()%ISOC%

set lock=
# test for "pwd" in extension
if "%menupwd%"=="" set menupwd=%pwd%
if "%menupwd%"=="" goto :nolock
if /i "%JE:~-3%"=="PWD" set JE=%JE:~0,-3% && set lock=1 && errorcheck off
if not "%lock%"=="1" goto :nolock
password %menupwd% && goto :nolock
echo && pause --wait=2 Wrong password!
goto :EOF

:nolock
set lock=
echo
errorcheck on

# if ends in 64 then remove '64'
if "%JE:~-2%"=="64" set JE=%JE:~0,-2%
# if ends in 32 then remove '32'
if "%JE:~-2%"=="32" set JE=%JE:~0,-2%


# if ends in AUTO then remove 'AUTO'
if /i "%JE:~-4%"=="AUTO" set JE=%JE:~0,-4% && set AUTOCSM=1

echo -e [QRUN.g4b] %ISOC%\nFile extension = %JE% %redir%
debug off
if "%E2BDEV%"=="" set E2BDEV=hd0 && pause WARNING: E2BDEV forced to hd0!

#message not contig e.g. $[0114]ERROR: %ISOC% IS NOT CONTIGUOUS (or is corrupt or missing)!\nPlease try RMPrepUSB-CTRL+F2 or run WinContig.exe to defragment all files.
call getstr.g4b $$STRberr ;; set emsg=%STR%

# Check if CRC32=CTRL or ISOBOOT=SHIFT
if "%JE%"==".isodd" goto :skpcrc
if "%JE%"==".isodefault" goto :skpcrc

if exist n calc %n%&4 && calc %n%&3 && echo -e -n \nSHIFT+CTRL KEYS PRESSED - CRC32 is...\x20 && crc32 %ISOC% && pause Press ENTER to continue booting...
:skpcrc
if exist n if /i "%JE%"==".iso" calc %n%&3 && calc %n%&4 || echo -e -n \nSHIFT KEY PRESSED - USING ISOBOOT && set /p:1 A= || call /%grub%/isoboot.g4b && exit
set n=

# Check if file is contiguous (don't check for certain extensions)
echo %JE% > (md)0x200+1
#cat --locatei=ISOPE  (md)0x200+1 > nul && goto :skipcont
#cat --locatei=ISOWIN (md)0x200+1 > nul && goto :skipcont
#cat --locatei=ISOWB  (md)0x200+1 > nul && goto :skipcont
#cat --locatei=ISOE0  (md)0x200+1 > nul && goto :skipcont
cat --locatei=MEM    (md)0x200+1 > nul && goto :skipcont
cat --locatei=GZ     (md)0x200+1 > nul && goto :skipcont
cat --locatei=VHD    (md)0x200+1 > nul && goto :skipcont
cat --locatei=WIM    (md)0x200+1 > nul && goto :skipcont
cat --locatei=ZIP    (md)0x200+1 > nul && goto :skipcont
cat --locatei=IMGFD  (md)0x200+1 > nul && goto :skipcont

blocklist %ISOC% > (md)0x200+1
set NOTCONTIG=
cat --locate=+ --number=1 (md)0x200+1 > nul
cat --locate=, --skip=%?% (md)0x200+1 > nul && set NOTCONTIG=1
if exist NOTCONTIG echo && call echo -e %emsg% && blocklist %ISOC% && debug -1 && pause --wait=2
# get start address
set FI=0
set r=
cat --locate=+ --replace="               " --number=1 (md)0x200+1 > nul
cat --locate=) (md)0x200+1 > nul
set /A r=%?%+1 > nul
cat --skip=%r% (md)0x200+1 | set /A FI= > nul
set r=

:skipcont
debug 0
if exist NOSUG goto :skipsugJE

# --- LOOK AT FILENAME AND SUGGEST BETTER FILE EXTENSION ---
set SUGJE=
echo %~n1 > (md)0x200+1
#Check filename and extension
if /i "%JE%"==".img"   cat --locatei=konboot (md)0x200+1 > nul && set SUGJE=.imgfdhd01 && goto SUGPROMPT
if /i "%JE%"==".img"   cat --locatei=Guru    (md)0x200+1 > nul && cat --locatei=partition (md)0x200+1 > nul  && set SUGJE=.imgnousb && goto SUGPROMPT
if /i "%JE%"==".img"   cat --locatei=FREEBSD (md)0x200+1 > nul && echo -e \n\n$[0x0e]NOTE: FreeBSD 9 and later will not work as an IMG file\nUse .imgPTNA5 and the 'memstick' image - see www.easy2boot.com for details %redir%  && pause --wait=5
if /i "%JE%"==".vhd"   set SUGJE=.vhdboot && echo -e \n\n$[0x0e].VHD is for Windows 7/8/10 - if XP-based VHD try .VHDBOOT\n\nTip: Use 'set NOSUG=1' in MyE2B.cfg to suppress these suggestions. %redir% && goto SUGPROMPT
if /i "%JE%"==".image" cat --locatei=haiku   (md)0x200+1 > nul && cat --locatei=anyboot (md)0x200+1 > nul  && set SUGJE=.haiku && goto SUGPROMPT
if not /i "%JE%"==".iso" goto skipsugJE

# We have .iso extension - check if this is ideal
cat --locatei=debian       (md)0x200+1 > nul && echo -e  \n\n$[0x0c]Tip: To install debian, set the 'cdrom' device path to /dev/sd$[0x74]X$[0x0c]4 (where $[0x74]X$[0x0c] = b or c or d or e). %redir% && echo %redir% 

cat --locatei=WIN          (md)0x200+1 > nul && set SUGJE=.isope01 && echo -e  \n\n$[0x0e]Tip: For best results, convert to .imgPTN file. %redir% && echo %redir% 
cat --locatei=DART         (md)0x200+1 > nul && set SUGJE=.isope01 && echo -e  \n\n$[0x0e]Tip: For best results, convert to .imgPTN file. %redir% && echo %redir% 
cat --locatei=ERD          (md)0x200+1 > nul && set SUGJE=.isope01 && echo -e  \n\n$[0x0e]Tip: For best results, convert to .imgPTN file. %redir% && echo %redir% 
cat --locatei=BART         (md)0x200+1 > nul && set SUGJE=.isomemF01

cat --locate=XP            (md)0x200+1 > nul && set SUGJE=.isomemwinv
# exceptions if MSDArt 5 2005 erd5 ERD Commander 2005 or 2007 or MSDaRT 5.0
cat --locatei=dart         (md)0x200+1 > nul && cat --locatei=2005 (md)0x200+1 > nul && set SUGJE=.isomemwinv
cat --locatei=dart         (md)0x200+1 > nul && cat --locatei=2007 (md)0x200+1 > nul && set SUGJE=.isomemwinv
cat --locatei=dart         (md)0x200+1 > nul && cat --locatei=50   (md)0x200+1 > nul && set SUGJE=.isomemwinv
cat --locatei=dart         (md)0x200+1 > nul && cat --locatei=5.0  (md)0x200+1 > nul && set SUGJE=.isomemwinv
cat --locatei=ERD          (md)0x200+1 > nul && cat --locatei=5    (md)0x200+1 > nul && set SUGJE=.isomemwinv
cat --locatei=ERD          (md)0x200+1 > nul && cat --locatei=2007 (md)0x200+1 > nul && set SUGJE=.isomemwinv
cat --locatei=ERD          (md)0x200+1 > nul && cat --locatei=2005 (md)0x200+1 > nul && set SUGJE=.isomemwinv
cat --locatei=ERD          (md)0x200+1 > nul && cat --locatei=50   (md)0x200+1 > nul && set SUGJE=.isomemwinv
cat --locatei=ERD          (md)0x200+1 > nul && cat --locatei=5.0  (md)0x200+1 > nul && set SUGJE=.isomemwinv
#MSDaRT 6.0, 6.5 7.0 8.0 8.1 
cat --locatei=ERD          (md)0x200+1 > nul && cat --locatei=60 (md)0x200+1 > nul && set SUGJE=.isope01
cat --locatei=ERD          (md)0x200+1 > nul && cat --locatei=65 (md)0x200+1 > nul && set SUGJE=.isope01
cat --locatei=ERD          (md)0x200+1 > nul && cat --locatei=70 (md)0x200+1 > nul && set SUGJE=.isope01
cat --locatei=ERD          (md)0x200+1 > nul && cat --locatei=80 (md)0x200+1 > nul && set SUGJE=.isope01
cat --locatei=ERD          (md)0x200+1 > nul && cat --locatei=81 (md)0x200+1 > nul && set SUGJE=.isope01
cat --locatei=spotmau      (md)0x200+1 > nul && set SUGJE=.isope01

cat --locatei=Boot_Genius  (md)0x200+1 > nul && set SUGJE=.isope01 && echo -e  \n\n$[0x0e]Tip: For best results, convert to .imgPTN file. %redir% && echo %redir% 
cat --locatei=winbuild     (md)0x200+1 > nul && set SUGJE=.isoWB && echo -e  \n\n$[0x0e]Tip: For best results, convert to .imgPTN file. %redir% && echo %redir% 
cat --locatei=strelec      (md)0x200+1 > nul && set SUGJE=.isofira01 && echo -e  \n\n$[0x0e]Tip: If problems, convert to .imgPTN file. %redir% && echo %redir% 
cat --locatei=XMPE         (md)0x200+1 > nul && set SUGJE=.isofira01 && echo -e  \n\n$[0x0e]Tip: If problems, convert to .imgPTN file. %redir% && echo %redir% 
cat --locatei=hiren        (md)0x200+1 > nul && set SUGJE=.isowinvh && echo -e  \n\n$[0x0e]Tip: For best results, convert to .imgPTN file. %redir% && echo %redir% 
cat --locatei=hbcd         (md)0x200+1 > nul && set SUGJE=.isowinvh && echo -e  \n\n$[0x0e]Tip: For best results, convert to .imgPTN file. %redir% && echo %redir% 
cat --locatei=DLCD         (md)0x200+1 > nul && set SUGJE=.isoHW && echo -e  \n\n$[0x0e]Tip: For best results, convert to .imgPTN file. %redir% && echo %redir% 
cat --locatei=DLC.         (md)0x200+1 > nul && set SUGJE=.isoHW && echo -e  \n\n$[0x0e]Tip: For best results, convert to .imgPTN file. %redir% && echo %redir% 
cat --locatei=DIUM         (md)0x200+1 > nul && set SUGJE=.isoPE01 && echo -e  \n\n$[0x0e]Tip: For Dium Desktop, convert to .imgPTN file and COMBINE menu.lst. %redir% && echo %redir% 
cat --locatei=tionmagic    (md)0x200+1 > nul && set SUGJE=.isoDOS
cat --locatei="tion magic" (md)0x200+1 > nul && set SUGJE=.isoDOS
cat --locatei="crypt"      (md)0x200+1 > nul && set SUGJE=.iso01
cat --locatei=truecryp     (md)0x200+1 > nul && set SUGJE=.iso01
cat --locatei="true crypt" (md)0x200+1 > nul && set SUGJE=.iso01
cat --locatei="puppy"      (md)0x200+1 > nul && set SUGJE=.isopup
cat --locatei="slacko"     (md)0x200+1 > nul && set SUGJE=.isopup
cat --locatei="precise"    (md)0x200+1 > nul && set SUGJE=.isopup
cat --locatei="macpup"     (md)0x200+1 > nul && set SUGJE=.isomacpup
cat --locate="WDE"         (md)0x200+1 > nul && set SUGJE=.isowinv
cat --locatei=winflp       (md)0x200+1 > nul && set SUGJE=.isowinvh
cat --locatei=windows      (md)0x200+1 > nul && cat --locatei=legacy (md)0x200+1 > nul && set SUGJE=.isowinvh
cat --locatei=POS          (md)0x200+1 > nul && cat --locatei=2009   (md)0x200+1 > nul && set SUGJE=.isowinvh && echo -e  \n\n$[0x0e]WARNING: Need to extract \i386 and \win*.* to root of USB drive %redir% && echo %redir% 
cat --locatei=ubcd4win     (md)0x200+1 > nul && set SUGJE=.isowinv
cat --locatei=ubcd         (md)0x200+1 > nul && cat --locatei=win    (md)0x200+1 > nul && set SUGJE=.isowinv

cat --locatei=falcon       (md)0x200+1 > nul && set SUGJE=.isowinvh && echo -e  \n\n$[0x0e]Tip: For best results, convert to .imgPTN file. %redir% && echo %redir% 
cat --locatei=f4ubcd       (md)0x200+1 > nul && set SUGJE=.isowinvh && echo -e  \n\n$[0x0e]Tip: For best results, convert to .imgPTN file. %redir% && echo %redir% 
cat --locatei=fd           (md)0x200+1 > nul && cat --locatei=src  (md)0x200+1 > nul && set SUGJE=.isonousb
cat --locatei=BSD          (md)0x200+1 > nul && echo -e \n\n$[0x1f]NOTE: FreeBSD 9 and later ISOs will not work as an ISO file\nUse .imgPTN+'memstick' images - see www.easy2boot.com for details %redir%  && pause --wait=5
cat --locate="MRI"         (md)0x200+1 > nul && set SUGJE=.isoPE01CD
cat --locatei="squad"      (md)0x200+1 > nul && set SUGJE=.isoPE01CD
cat --locatei="NBRT"       (md)0x200+1 > nul && set SUGJE=.isoPE01
cat --locatei="Norton"     (md)0x200+1 > nul && set SUGJE=.isoPE01

cat --locatei=ubuntu       (md)0x200+1 > nul && set SUGJE=.iso && echo -e  \n\n$[0x1f]Tip: To Install use  'mount /dev/sdb4 /cdrom' in shell then exit and detect CD-ROM. %redir% && echo %redir% 
cat --locatei=crunchba     (md)0x200+1 > nul && set SUGJE=.iso && echo -e  \n\n$[0x1f]Tip: To Install use  'mount /dev/sdb4 /cdrom' in shell then exit and detect CD-ROM. %redir% && echo %redir% 
cat --locatei=kali         (md)0x200+1 > nul && set SUGJE=.iso && echo -e  \n\n$[0x1f]Tip: To Install see www.easy2boot.com 'List of tested ISOs'. %redir% && echo %redir% 
cat --locatei=pos2009      (md)0x200+1 > nul && set SUGJE=.iso && echo -e  \n\n$[0x1f]Tip: To Install see www.easy2boot.com 'List of tested ISOs'. %redir% && echo %redir% 
cat --locatei=proxmox      (md)0x200+1 > nul && set SUGJE=.iso && echo -e  \n\n$[0x1f]Tip: See www.easy2boot.com 'List of tested ISOs' for instructions. %redir% && echo %redir% 
cat --locatei=dsl-         (md)0x200+1 > nul && set SUGJE=.iso && echo -e  \n\n$[0x1f]Tip: See www.easy2boot.com 'List of tested ISOs' for instructions. %redir% && echo %redir% 
cat --locatei=wte_boot     (md)0x200+1 > nul && set SUGJE=.iso && echo -e  \n\n$[0x1f]Tip: See www.easy2boot.com 'List of tested ISOs' for instructions. %redir% && echo %redir% 
cat --locatei=gandalf      (md)0x200+1 > nul && set SUGJE=.iso && echo -e  \n\n$[0x1f]Tip: See www.easy2boot.com 'List of tested ISOs' for instructions. %redir% && echo %redir% 
cat --locatei=tenorshare   (md)0x200+1 > nul && set SUGJE=.isoPE01 && echo -e  \n\n$[0x1f]Tip: See www.easy2boot.com 'List of tested ISOs' for instructions. %redir% && echo %redir% 


if exist redirp goto :skipsugJE
if exist redir goto :SUGPROMPT

if /i "%JE%"==".iso" if not exist SUGJE  && set SUGJE=.isoask

:SUGPROMPT
if "%SUGJE%"=="" goto %JE%
echo
set ask=N
#ask Change File extension?
if not exist redir call getstr.g4b $$STRbsug ;; if not exist redir if /i "%JE%"==".iso" call echo -e %STR%
if not exist redir call getstr.g4b $$STRbsuf ;; if not exist redir call set /p:4 ask=%STR%
errorcheck on
if /i "%ask%"=="I"  set ask= && set JE=.isoask
if /i "%ask%"=="A"  set ask= && set SUGJE= && exit
if /i "%ask%"=="y" set JE=%SUGJE%
if not exist redir echo -e \n
if not exist redir set /p:1 ask=%JE% --->
set SUGJE=
set ask=
echo -e \n

:skipsugJE

errorcheck off
#remove animated icon fd3 (and fd2)
map --unmap=3 > nul
map --unmap=2 > nul
map --rehook > nul

goto %JE%

pause FAILED QRUN!
goto %JE%
exit

# ---------- THE ROUTINES BELOW ARE EXECUTED DEPENDING ON THE FILE EXTENSION --------------

:.isoPECD
call :.isoPE
chainloader (0xff)
exit

:.isoPE01CD
call :.isoPE01
chainloader (0xff)
exit

:.imafdhdd0
# map payload as large fd and first internal hdd as hd0 only
map %ISOC% (fd0) || map --mem %ISOC% (fd0)
map --hook
set A=
if exist (fd0)/IO.SYS set A=1
if exist (fd0)/KERNEL.SYS set A=1
if not exist A set /p A=WARNING: IO.SYS or KERNEL.SYS boot files not in image file!
set A=
map (hd1) (hd0)
map --hook
#set just one HDD and one floppy
map --harddrives=1
map --floppies=1
root (fd0)
chainloader /IO.SYS || chainloader /KERNEL.SYS || chainloader (fd0)+1


:.imghdlinux
set PT=0x83

#generic entry point to boot any disk image if PT is set in hex type - e.g. set PT=0x83
:.imghdPT
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix
if not exist CD partnew (%E2BDEV%,3) %PT% %ISOC% || echo && call echo -e %emsg% && call :waitexit

dd if=(%E2BDEV%)0+1 of=(md)0x300+1 > nul
# get length
read 0x601fa > nul
set /A LEN=%@retval%&0xffffffff > nul
#echo ***** LEN=%LEN%
map --read-only --heads=0 --sectors-per-track=0 %ISOC% (hd15) > nul
map --hook
dd if=(hd15)0+1 of=(md)0x300+1 > nul
# check for valid MBR
read 0x601fe > nul
set /A MAGIC=%@retval%&0xffff > nul
if /i not "%MAGIC%"=="0xaa55" echo -e SORRY: %ISOC% is not a decompressed whole-disk image file.\nUse WinRar or 7Zip to extract the file and use that instead! && partnew (%E2BDEV%,3) 0 0 0 > nul && call :waitexit
set MAGIC=
# find partition
set STOFF=
set /A TYP=*0x601c2 & 0xff > nul
if /i "%PT%"=="%TYP%" && set STOFF=0x601c6 && echo Found %PT% partition in PTN 1 of %ISOC% %redir%
set /A TYP=*0x601d2 & 0xff > nul
if /i "%PT%"=="%TYP%" && set STOFF=0x601d6 && echo Found %PT%partition in PTN 2 of %ISOC% %redir%
set /A TYP=*0x601e2 & 0xff > nul
if /i "%PT%"=="%TYP%" && set STOFF=0x601e6 && echo Found %PT%partition in PTN 3 of %ISOC% %redir%
set /A TYP=*0x601f2 & 0xff > nul
if /i "%PT%"=="%TYP%" && set STOFF=0x601f6 && echo Found %PT%partition in PTN 4 of %ISOC% %redir%
if "%STOFF%"=="" set /p A=SORRY: Cannot find a type %PT% partition in the image! 
if "%STOFF%"=="" partnew (%E2BDEV%,3) 0 0 0 && configfile (md)0xA000+0x50
set TYP=
# get start PBR inside image
read %STOFF% > nul
set /A OFFSTART=%@retval%&0xffffffff > nul
#echo ***** OFFSTART=%OFFSTART%
set /A L=%LEN%-%OFFSTART% > nul
#echo **** L=%L% OFFSTART=%OFFSTART%
echo Creating new partition 4 on %E2BDEV% using command: partnew (%E2BDEV%,3) %PT% (%E2BDEV%,3)%OFFSTART%+%L% %redir%
partnew (%E2BDEV%,3) %PT%  (%E2BDEV%,3)%OFFSTART%+%L%

errorcheck off
echo
ls (%E2BDEV%,3)/
echo
# remove part type now before we map hd0
parttype (%E2BDEV%,3) 0
errorcheck on
echo
# unmap file
map --unmap=0x8f
#map whole disk image to hd0
map --heads=0 --sectors-per-track=0 %ISOC% (hd0) > nul || map --mem --heads=0 --sectors-per-track=0 %ISOC% (hd0)
map --hook
root (hd0,0) || rootnoverify (hd0,0)
chainloader (hd0)+1 || chainloader (hd0,0)+1 || chainloader (hd0,3)+1
rootnoverify (hd0,0)
set STOFF=
set L=
set OFFSTART=
set LEN=

exit


:.isoBF
# Permanently remove bootfix.bin from ISO to suppress 'Press a key to boot from CD' prompt
map %ISOC% (0xff) > nul
map --hook > nul
cat --locatei=BOOTFIX.BIN --number=1 --replace=XXX (0xff)+0x3000 > nul && pause --wait=3 WARNING: BOOTFIX.BIN 'Press a key to boot from CD' has now been removed from the ISO file!
goto :.iso

:.vhdgrldr
map %ISOC% (hd0) > nul
map --hook > nul
root (hd0,0) > nul || rootnoverify (hd0,0) > nul
chainloader /grldr || chainloader (hd0,0)+1 || chainloader (hd0)+1
exit

:.vhdfira
:.firavhd
#for VHDs that use FiraDisk
errorcheck on
map --heads=2 --sectors-per-track=18 --mem (md)0x800+4 (99)
map %ISOC% (hd0) || map --mem %ISOC% (hd0)
map --hook
write (99) [FiraDisk]\nStartOptions=disk,vmem=find:%~pnx1,boot;\n\0
rootnoverify (hd0,0)
chainloader /bootmgr || chainloader /BOOTMGR || chainloader /ntldr || chainloader +1 || chainloader (hd0)+1
exit

:.WIM
:.WIMNT6
:.VHDX
:.VHD
#check name for spaces
echo -e -n %ISOC% > (md)0x300+1
cat --locate=\x20 --number=1 (md)0x300+1 > nul && echo -e $[0x0c]ERROR: Path must not contain spaces! && call :waitexit

set ntldr=
if exist (%E2BDEV%,1)/bootmgr set ntldr=(%E2BDEV%,1)/bootmgr
if exist (%E2BDEV%,0)/bootmgr set ntldr=(%E2BDEV%,0)/bootmgr
if exist %_BOOT%/%grub%/DPMS/NTBOOT.MOD/bootmgr set ntldr=%_BOOT%/%grub%/DPMS/NTBOOT.MOD/bootmgr
if not exist ntldr echo -e $[0x0c]COMPATIBLE BOOTMGRS ARE (check size is same):\n25-07-2012 398,156\n22-08-2013 427,680\n18-03-2014 398,356\n14-06-2014 404,250\n20-01-2015 409,154\n10-02-2016 403,390\n17-05-2016 400,517\n
if not exist ntldr echo -e $[0x0e]ERROR: Required file 'BOOTMGR' is missing!\nPlease copy BOOTMGR to /%grub%/DPMS/NTBOOT.MOD folder && pause Press ENTER to continue... 
cat --length=0 %ntldr% > nul
set /a BM=%@retval% > nul
#check for good bootmgr
if exist BM if %BM%==398156 set BM=999
if exist BM if %BM%==427680 set BM=999
if exist BM if %BM%==398356 set BM=999
if exist BM if %BM%==404250 set BM=999
if exist BM if %BM%==409154 set BM=999
if exist BM if %BM%==403390 set BM=999
if exist BM if %BM%==400517 set BM=999
#new for 1.82
if exist BM if %BM%==398144 set BM=999
if exist BM if %BM%==389720 set BM=999
#if not %BM%==999  echo -e $[0x0c]COMPATIBLE BOOTMGRS ARE (check size is same):\n25-07-2012 398,156\n22-08-2013 427,680\n18-03-2014 398,356\n14-06-2014 404,250\n20-01-2015 409,154\n10-02-2016 403,390\n17-05-2016 400,517\n
if not %BM%==999  echo -e $[0x0c]COMPATIBLE BOOTMGRS ARE (check size is same):\n398,156\n427,680\n398,356\n404,250\n409,154\n403,390\n400,517\n398,144\n389,720\n
if not %BM%==999  echo -e $[0x0c]ERROR: INCOMPATIBLE BOOTMGR Size=%BM% (may cause BSOD error or reset)!\nPlease replace %ntldr% with a compatible version (e.g. Win8.1 version).\n && pause Press ENTER to continue booting...
set BM=
if exist ntldr /%grub%/NTBOOT NT6=%ISOC% NTLDR=%ntldr% || /%grub%/NTBOOT NT6=%ISOC%
exit


# Requires NTBOOT.PE
#:.wimpe1
if not exist %_BOOT%/%grub%/DPMS/NTBOOT.MOD/NTBOOT.PE1 echo ERROR: NTBOOT.PE1 and other files missing from %_BOOT%/%grub%/DPMS/NTBOOT.MOD/ folder! && call :waitexit
/%grub%/NTBOOT PE1=%ISOC%
exit

# Requires NTBOOT.NT5
#:.imgnt5
#:.imgXP
if not exist %_BOOT%/%grub%/DPMS/NTBOOT.MOD/NTBOOT.NT5 echo ERROR: NTBOOT.NT5 and other files missing from %_BOOT%/%grub%/DPMS/NTBOOT.MOD/ folder! && call :waitexit
/%grub%/NTBOOT NT5=%ISOC%
exit

# Requires VBOOT.ISO
#:.VHDXNT5
#:.VHDNT5
if not exist %_BOOT%/%grub%/DPMS/NTBOOT.MOD/VBOOT.ISO echo ERROR: VBOOT.ISO and other files missing from %_BOOT%/%grub%/DPMS/NTBOOT.MOD/ folder! && call :waitexit
/%grub%/NTBOOT VBOOT=%ISOC%
exit


:.imgBeOS
:.HAIKU
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix

if not exist CD partnew (%E2BDEV%,3) 0xEB %ISOC% || echo && call echo -e %emsg% && call :waitexit
dd if=(%E2BDEV%)0+1 of=(md)0x300+1 > nul
# get length
read 0x601fa > nul
set /A LEN=%@retval%&0xffffffff > nul
#echo ***** LEN=%LEN%

map --read-only %ISOC% (hd15) > nul
map --hook
dd if=(hd15)0+1 of=(md)0x300+1 > nul
# check for valid MBR
read 0x601fe > nul
set /A MAGIC=%@retval%&0xffff > nul
if /i not "%MAGIC%"=="0xaa55" echo -e SORRY: %ISOC% is not a decompressed file - please try WinRar or 7Zip to decompress it first! && partnew (%E2BDEV%,3) 0 0 0 > nul && call :waitexit
set MAGIC=

# find EB partition
set STOFF=
set /A TYP=*0x601c2 & 0xff > nul
if /i "0xeb"=="%TYP%" && set STOFF=0x601c6 && echo Found EB partition in PTN 1 of %ISOC% %redir%
set /A TYP=*0x601d2 & 0xff > nul
if /i "0xeb"=="%TYP%" && set STOFF=0x601d6 && echo Found EB partition in PTN 2 of %ISOC% %redir%
set /A TYP=*0x601e2 & 0xff > nul
if /i "0xeb"=="%TYP%" && set STOFF=0x601e6 && echo Found EB partition in PTN 3 of %ISOC% %redir%
set /A TYP=*0x601f2 & 0xff > nul
if /i "0xeb"=="%TYP%" && set STOFF=0x601f6 && echo Found EB partition in PTN 4 of %ISOC% %redir%

if "%STOFF%"=="" partnew (%E2BDEV%,3) 0 0 0 > nul && set /p A=SORRY: Cannot find a type EB partition in the image! Press ENTER... || configfile (md)0xA000+0x50
set TYP=
# get start PBR inside image
read %STOFF% > nul
set /A OFFSTART=%@retval%&0xffffffff > nul
#echo ***** OFFSTART=%OFFSTART%

set /A L=%LEN%-%OFFSTART% > nul
#echo **** L=%L% OFFSTART=%OFFSTART%
echo
echo -e Creating new partition 4 on %E2BDEV% using command: partnew (%E2BDEV%,3) 0xEB (%E2BDEV%,3)%OFFSTART%+%L%\nYou will need to remove partition 4 when you next boot E2B (see Sample_MyE2B.cfg for details). %redir%
partnew (%E2BDEV%,3) 0xEB  (%E2BDEV%,3)%OFFSTART%+%L%
echo


# patch 4 bytes at 1fa (506 dec) with ptn start
dd if=(%E2BDEV%,3)+1 of=(md)0x300+1
dd if=(%E2BDEV%)+1 of=(md)0x200+1

debug 1
#echo -e -n Partition offset was\x20 && read 0x601fa
#echo -e -n Partition start =\x20
read 0x401f6 > nul
set patch=%@retval% 
write 0x601fa %patch% > nul
echo
echo Patching offset 506 in sector (%E2BDEV%,3) with value %patch%... %redir%
dd of=(%E2BDEV%,3)+1 if=(md)0x300+1 > nul

# unmap file
map --unhook
map --unmap=0x8f
# boot from new partition
chainloader (%E2BDEV%,3)+1
rootnoverify (%E2BDEV%,3)
set STOFF=
set L=
set OFFSTART=
set LEN=
set patch=

# ptn type must be kept as EB or won't boot

exit


:.HFS
:.HFSPTN
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix
if not exist CD partnew (%E2BDEV%,3) 0xAF %ISOC% || echo && call echo -e %emsg% && call :waitexit
dd if=(%E2BDEV%)0+1 of=(md)0x300+1 > nul
# check for valid MBR
read 0x601fe > nul
set /A MAGIC=%@retval%&0xffff > nul
if /i not "%MAGIC%"=="0xaa55" echo -e \nSORRY: %ISOC% is not a decompressed partition image.\nTry WinRAR or 7Zip to unzip it first! && partnew (%E2BDEV%,3) 0 0 0 > nul && call :waitexit
set MAGIC=


# if we have a auxilliary 2nd ptn (no extension) then put that in (%E2BDEV%,2)
#if exist %~dpn1 partnew (%E2BDEV%,2) 0x0 %~dpn1 %redir% && echo && echo -e Auxillary partition = %~pn1 %redir%


rootnoverify (%E2BDEV%,3) > nul
chainloader (%E2BDEV%,3)+1 > nul
exit


:.DMG
:.DMGHFS
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix
if not exist CD partnew (%E2BDEV%,3) 0xAF %ISOC% || echo && call echo -e %emsg% && call :waitexit

dd if=(%E2BDEV%)0+1 of=(md)0x300+1 > nul
# get length
read 0x601fa > nul
set /A LEN=%@retval%&0xffffffff > nul
#echo ***** LEN=%LEN%

map --read-only %ISOC% (hd15) > nul
map --hook
dd if=(hd15)0+1 of=(md)0x300+1 > nul
# check for valid MBR
read 0x601fe > nul
set /A MAGIC=%@retval%&0xffff > nul
if /i not "%MAGIC%"=="0xaa55" echo -e SORRY: %ISOC% is not a decompressed whole-disk image file.\nUse WinRar or 7Zip to extract the .hfs file and use that instead! && partnew (%E2BDEV%,3) 0 0 0 > nul && call :waitexit
set MAGIC=

# find AF partition
set STOFF=
set /A TYP=*0x601c2 & 0xff > nul
if /i "0xaf"=="%TYP%" && set STOFF=0x601c6 && echo Found AF partition in PTN 1 of %ISOC% %redir%
set /A TYP=*0x601d2 & 0xff > nul
if /i "0xaf"=="%TYP%" && set STOFF=0x601d6 && echo Found AF partition in PTN 2 of %ISOC% %redir%
set /A TYP=*0x601e2 & 0xff > nul
if /i "0xaf"=="%TYP%" && set STOFF=0x601e6 && echo Found AF partition in PTN 3 of %ISOC% %redir%
set /A TYP=*0x601f2 & 0xff > nul
if /i "0xaf"=="%TYP%" && set STOFF=0x601f6 && echo Found AF partition in PTN 4 of %ISOC% %redir%

if "%STOFF%"=="" partnew (%E2BDEV%,3) 0 0 0 > nul && echo SORRY: Cannot find a type AF (HFS) partition in the image!
if "%STOFF%"=="" call :waitexit
set TYP=

# get start PBR inside image
read %STOFF% > nul
set /A OFFSTART=%@retval%&0xffffffff > nul
#echo ***** OFFSTART=%OFFSTART%

set /A L=%LEN%-%OFFSTART% > nul
#echo **** L=%L% OFFSTART=%OFFSTART%
echo Creating new partition 4 on %E2BDEV% using command: partnew (%E2BDEV%,3) 0xAF  (%E2BDEV%,3)%OFFSTART%+%L% %redir%
partnew (%E2BDEV%,3) 0xAF  (%E2BDEV%,3)%OFFSTART%+%L%

# unmap file
map --unhook
map --unmap=0x8f

# boot from new partition
chainloader (%E2BDEV%,3)+1
rootnoverify (%E2BDEV%,3)
set STOFF=
set L=
set OFFSTART=
set LEN=

exit




:.isonousb
# map ISO as floppy but remove USB drive as HDD (for DOS floppy images)
set HDDS=
if not exist HDDS geometry (hd10) > nul && set HDDS=10
if not exist HDDS geometry (hd9) > nul && set HDDS=9
if not exist HDDS geometry (hd8) > nul && set HDDS=8
if not exist HDDS geometry (hd7) > nul && set HDDS=7
if not exist HDDS geometry (hd6) > nul && set HDDS=6
if not exist HDDS geometry (hd5) > nul && set HDDS=5
if not exist HDDS geometry (hd4) > nul && set HDDS=4
if not exist HDDS geometry (hd3) > nul && set HDDS=3
if not exist HDDS geometry (hd2) > nul && set HDDS=2
if not exist HDDS geometry (hd1) > nul && set HDDS=1
if not exist HDDS echo No hard disk found! 
if not exist HDDS call :waitexit

map --mem %ISOC% (0xff)
#map the first partition of the USB disk as a floppy disk
map (%E2BDEV%,0)+1 (fd0)
#map the whole UFD as a virtual cd
map (%E2BDEV%) (hd32)
#map the real hard disk as hard disk -1
if %HDDS%>=1 map (hd1) (hd0)
if %HDDS%>=2 map (hd2) (hd1)
if %HDDS%>=3 map (hd3) (hd2)
if %HDDS%>=4 map (hd4) (hd3)
if %HDDS%>=5 map (hd5) (hd4)
if %HDDS%>=6 map (hd6) (hd5)
if %HDDS%>=7 map (hd7) (hd6)
if %HDDS%>=8 map (hd8) (hd7)
if %HDDS%>=9 map (hd9) (hd8)
if %HDDS%>=10 map (hd10) (hd9)
# set one floppy disk
map --floppies=1
# sets number of HDDs in system - 1
map --harddrives=%HDDS%
map --hook
root (0xff) || rootnoverify (0xff)
#map --status
echo
echo USB drive now appears as Floppy Disk 0: %redir%
echo
ls (fd0)/
echo
echo
echo Hard Disks in system = %HDDS% %redir%
echo
errorcheck off
pause --wait=4
chainloader (0xff) || chainloader /kernel.sys || chainloader /io.sys
exit


:.imgnousb
:.imanousb
# map as floppy but remove USB drive as HDD (for DOS floppy images)
set HDDS=
if not exist HDDS geometry (hd10) > nul && set HDDS=10
if not exist HDDS geometry (hd9) > nul && set HDDS=9
if not exist HDDS geometry (hd8) > nul && set HDDS=8
if not exist HDDS geometry (hd7) > nul && set HDDS=7
if not exist HDDS geometry (hd6) > nul && set HDDS=6
if not exist HDDS geometry (hd5) > nul && set HDDS=5
if not exist HDDS geometry (hd4) > nul && set HDDS=4
if not exist HDDS geometry (hd3) > nul && set HDDS=3
if not exist HDDS geometry (hd2) > nul && set HDDS=2
if not exist HDDS geometry (hd1) > nul && set HDDS=1
if not exist HDDS echo No hard disk found! 
if not exist HDDS call :waitexit

map --mem %ISOC% (fd0) || map %ISOC% (fd0)
#map the first partition of the USB disk as a floppy disk
map (%E2BDEV%,0)+1 (fd1)
#map the whole UFD as a virtual cd
map (%E2BDEV%) (hd32)
#map the real hard disk as hard disk-1 
if %HDDS%>=1 map (hd1) (hd0)
if %HDDS%>=2 map (hd2) (hd1)
if %HDDS%>=3 map (hd3) (hd2)
if %HDDS%>=4 map (hd4) (hd3)
if %HDDS%>=5 map (hd5) (hd4)
if %HDDS%>=6 map (hd6) (hd5)
if %HDDS%>=7 map (hd7) (hd6)
if %HDDS%>=8 map (hd8) (hd7)
if %HDDS%>=9 map (hd9) (hd8)
if %HDDS%>=10 map (hd10) (hd9)
# set two floppy disk
map --floppies=2
# sets number of HDDs in system-1
map --harddrives=%HDDS%
map --hook
root (fd0) || rootnoverify (fd0)
echo
echo Floppy 0 = %FD% %redir%
ls (fd0)/
echo
echo
echo Floppy 1 = USB DRIVE %redir%
ls (fd1)/
echo
#map --status
echo
echo Hard Disks in system = %HDDS% %redir%
echo
errorcheck off
pause --wait=4 %redir%
chainloader /kernel.sys || chainloader /io.sys || chainloader (fd0)+1
exit

:.LKRN
:.KRN
# kernel boot - e.g. iPXE kernels
kernel %ISOC%
exit


:.cfg
if not exist /_ISO/MyE2B.cfg echo ERROR: To use a .cfg file you must have a large blank /_ISO/MyE2B.cfg file! && call :waitexit
cat --locate="!BAT" --length=8 %ISOC% > nul || echo -e ERROR: %ISOC% does not start with !BAT - please use a valid MyE2B.cfg file format && call :waitexit
echo

cat --length=0 ()/_ISO/MyE2B.cfg > nul
set /a CL=*0x8290 > nul
cat --length=0 %ISOC% > nul
set /a IL=*0x8290 > nul
set /a CL=%CL% + 1 > nul
if %CL%<=%IL% echo -e \n$[0x0c]ERROR: ()/_ISO/MyE2B.cfg (%CL%) is smaller than %ISOC% (%IL%)\n\nPlease copy /_ISO/docs/MyThemes/$Default E2B Menu.cfg to /_ISO/MyE2B.cfg.  && call :waitexit
debug 1
echo -e Overwriting \\_ISO\\MyE2B.cfg file with %ISOC%... %redir%
# fill (rd) with 0's , 0x82d0 is rd-base mem address, Fn24 is memset - fill memory  <addr> <string> <size>
# OLD map (md)0x300+200 (rd) > nul ;; read 0x82d0 > nul ;; call Fn.24  %@retval% 0x20  102400 > nul 
call Fn.24  0x60000 0x20  102400 > nul ;; map (md)0x300+200 (rd) > nul
dd if=(rd)+1 of=()/_ISO/MYE2B.cfg > nul
dd if=%ISOC% of=()/_ISO/MyE2B.cfg > nul
set CL=
set IL=
chainloader /grldr
exit


:.gzmd
# uses memdisk to load into memory 
kernel (bd)/%grub%/memdisk
initrd %ISOC%
exit

:.zip
# uses memdisk to load a zip file into memory (e.g. dos622.zip which contains dos622.ima)
kernel (bd)/%grub%/memdisk raw
initrd %ISOC%
exit

:.bin
kernel %ISOC% 
exit

:.imghd
errorcheck off
if not exist CD map (hd0) (hd1)
if not exist CD map (hd1) (hd0)
errorcheck on
map --heads=0 --sectors-per-track=0 %ISOC% (hd0) > nul || map --mem --heads=0 --sectors-per-track=0 %ISOC% (hd0)
map --hook
rootnoverify (hd0,0)
chainloader /ntldr || chainloader /bootmgr || chainloader /BOOTMGR || chainloader /io.sys || chainloader /kernel.sys || chainloader +1 || chainloader (hd0)+1
exit

:.imgmemhd
:.imgmem
errorcheck off
if not exist CD map (hd0) (hd1)
if not exist CD map (hd1) (hd0)
errorcheck on
map --heads=0 --sectors-per-track=0 --mem %ISOC% (hd0)
map --hook
rootnoverify (hd0,0)
chainloader /ntldr || chainloader /bootmgr || chainloader /BOOTMGR || chainloader /io.sys || chainloader /kernel.sys || chainloader +1 || chainloader (hd0)+1
exit

:.IMAnomem
:.IMArw
map --heads=0 --sectors-per-track=0 %ISOC% (fd0)
map --hook
root (fd0) || rootnoverify (fd0)
chainloader (fd0)/io.sys || chainloader (fd0)/kernel.sys || chainloader (fd0)+1
exit

:.imz
echo  -e \n$[0x0c] .IMZ IS NOT SUPPORTED
echo Use WINIMAGE to save it as a .IMA file.
pause
exit

:.imgfd
:.ima
:.imggz
:.img
:.imgmem
:.imafd
:.gz
:.imagz
:.imagzmem
:.gzfd
:.imamem
:.imgmemfd
:.imgfd
map --heads=0 --sectors-per-track=0 --mem %ISOC% (fd0)
map --hook
root (fd0) || rootnoverify (fd0)
chainloader (fd0)/io.sys || chainloader (fd0)/kernel.sys || chainloader (fd0)+1
exit

:.imgfdhd01
# swap hd0 hd1 (e.g. for KonBoot)
errorcheck off
if not exist CD map (hd1) (hd0)
if not exist CD map (hd0) (hd1)
map --heads=0 --sectors-per-track=0 --mem %ISOC% (fd0)
map --hook
root (fd0) || rootnoverify (fd0)
chainloader (fd0)/io.sys || chainloader (fd0)/kernel.sys || chainloader (fd0)+1
exit

:.isoDOS
# copies the contents of the ISO to a virtual floppy disk
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix
# If the ISO is a DOS iso and tries to load a CDROM driver, it will fail - but the CD contents will be on drive B: ready to use
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC% || blocklist %ISOC% && call echo -e %emsg% && set /p A=Press ENTER...
map %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
map --hook
cat --length=0 %ISOC% ;; set /a LEN=*0x8290 ;; echo Length of %ISOC% is %LEN% bytes %redir%
set /a LEN=%LEN%/512
# Allow for PBR sectors etc. - must be FAT16 so over 0x20000
set /a LEN=%LEN%+0x1000
if %LEN%<=0x20000 set /a LEN=0x20000+0
echo Drive B: Length=%LEN% sectors %redir% && pause --wait=2 > nul
# call the copy batch file - first parameter is either (fd0) or (fd1) - next parameter is size of virtual drive (0x100000=512MiB)
call (bd)/%grub%/copyFF.g4b (fd0) %LEN%
echo PLEASE NOTE: Contents of CD are now on drive B: && pause Press ENTER to continue...
# set number of floppies seen by BIOS - must be 2 if using (fd1) instead of (fd0)
map --floppies=2
root (0xff)
chainloader /io.sys || chainloader /kernel.sys || chainloader (0xff)
exit

:.isoDOS01
# copies the contents of the ISO to a virtual floppy disk
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix
# If the ISO is a DOS iso and tries to load a CDROM driver, it will fail - but the CD contents will be on drive B: ready to use
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC% || blocklist %ISOC% && call echo -e %emsg% && pause > nul
map %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
map --hook
cat --length=0 %ISOC% ;; set /a LEN=*0x8290 ;; echo Length of %ISOC% is %LEN% bytes %redir%
set /a LEN=%LEN%/512
# Allow for PBR sectors etc. - must be FAT16 so over 0x20000
set /a LEN=%LEN%+0x1000
if %LEN%<=0x20000 set /a LEN=0x20000+0
echo Drive B: Length=%LEN% sectors %redir% && pause --wait=2 > nul
# call the copy batch file - first parameter is either (fd0) or (fd1) - next parameter is size of virtual drive (0x100000=512MiB)
call (bd)/%grub%/copyFF.g4b (fd0) %LEN%
echo PLEASE NOTE: Contents of CD are now on drive B: && pause Press ENTER to continue...
# set number of floppies seen by BIOS - must be 2 if using (fd1) instead of (fd0)
map --floppies=2
errorcheck off
if not exist CD map (hd0) (hd1)
if not exist CD map (hd1) (hd0)
errorcheck on
map --hook
root (0xff)
chainloader /io.sys || chainloader /kernel.sys || chainloader (0xff)
exit

##:.iso64mem
:.isomem
errorcheck off
# ignore error if not contiguous
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC%
errorcheck on
map --mem %ISOC% (0xff)
#map --mem (bd)/%grub%/firadisk.gz (fd0)
map --hook
root (0xff) || rootnoverify (0xff)
chainloader (0xff)/I386/setupldr.bin || chainloader (0xff)/minint/setupldr.bin || chainloader (0xff)/cmdcons/setupldr.bin || chainloader (0xff)
exit

##:.iso64win
:.isowin
# use for non-bootable windows ISOs
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC% || blocklist %ISOC% && call echo -e %emsg% && pause > nul
map  %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
#map --mem (bd)/%grub%/firadisk.gz (fd0)
map --hook
root (0xff) || rootnoverify (0xff)
chainloader (0xff)/I386/setupldr.bin || chainloader (0xff)/minint/setupldr.bin || chainloader (0xff)/cmdcons/setupldr.bin || chainloader (0xff)/ntldr || chainloader (0xff)/bootmgr || chainloader (0xff)/BOOTMGR || chainloader (0xff)
exit

##:.iso64linux
:.isolinux
# non-booting linux ISO
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC% || blocklist %ISOC% && call echo -e %emsg% && pause 
map  %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
#map --mem (bd)/%grub%/firadisk.gz (fd0)
map --hook
root (0xff) || rootnoverify (0xff)
chainloader (0xff)/isolinux.bin  || chainloader (0xff)/boot/isolinux.bin || chainloader (0xff)/boot/isolinux/syslinux.bin || chainloader (0xff)
exit

##:.iso64grub
:.isogrub
#non-booting grub/grub4dos iso
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC% || blocklist %ISOC% && call echo -e %emsg% && pause
map  %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
#map --mem (bd)/%grub%/firadisk.gz (fd0)
map --hook
root (0xff) || rootnoverify (0xff)
chainloader (0xff)/grldr || chainloader (0xff)
exit

##:.iso64force
:.isoforce
# force it to boot - may crash! - use for CentOS ISOs
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC% || blocklist %ISOC% && call echo -e %emsg% && pause 
map  %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
#map --mem (bd)/%grub%/firadisk.gz (fd0)
map --hook
root (0xff) || rootnoverify (0xff)
chainloader --force (0xff)
exit

##:.iso6401
:.iso01
errorcheck off
if not exist CD map (hd1) (hd0)
if not exist CD map (hd0) (hd1)
goto :.isodd

##:.iso64
:.iso
# if isoask=1 and running from winpe folder then always run .isope
# if /i "%~pn1%=="/_ISO/WINPE/" if "%ISOASK%"=="1" goto :.isope
if "%ISOASK%"=="1" goto :.isoask

##:.iso64dd
:.isodd
:.isodefault
:.isodef
# main ISO boot entry

# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix

if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC% || blocklist %ISOC% && call echo -e %emsg% && pause
map  %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
#firadisk removed as causes hang on some systems - e,g,  HP Pavilion DV6 laptop 
#map --mem (bd)/%grub%/firadisk.gz (fd0)
map --hook
root (0xff) || rootnoverify (0xff)
#chainloader (0xff)/I386/setupldr.bin || chainloader (0xff)/minint/setupldr.bin || chainloader (0xff)/cmdcons/setupldr.bin || chainloader (0xff)/ntldr || chainloader (0xff)/bootmgr || chainloader (0xff)/BOOTMGR || chainloader (0xff) || chainloader --force (0xff) 
chainloader (0xff) || chainloader --force (0xff)
exit

###:.iso64gz
:.isogz
map  %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
#firadisk removed as causes hang on some systems - e,g,  HP Pavilion DV6 laptop 
#map --mem (bd)/%grub%/firadisk.gz (fd0)
map --hook
root (0xff) || rootnoverify (0xff)
chainloader (0xff)
exit


:.isoHW
# use for Hirens with XP + WinPE8/8/10 (need a removable drive or Helper drive if using USB HDD for Win7/8/10)
call :.isope
#fix for some bad BIOSes giving blank screen on boot
map --e820cycles=0
map --mem (bd)/%grub%/winvblock.img.gz (fd0)
map --mem (bd)/%grub%/winvblock.img.gz (fd1)
map --hook
exit

:.isowinvH
#e.g. for Hirens
errorcheck off
# ignore error if not contiguous
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC%
errorcheck on
map %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
map --mem (bd)/%grub%/winvblock.img.gz (fd0)
map --mem (bd)/%grub%/winvblock.img.gz (fd1)
#if not exist CD map (hd1) (hd0)
#if not exist CD map (hd0) (hd1)
map --hook
root (0xff) || rootnoverify (0xff)
chainloader (0xff)/I386/setupldr.bin || chainloader (0xff)/I386/setupldr.bin || chainloader (0xff)/ntldr || chainloader (0xff)/bootmgr || chainloader (0xff)/BOOTMGR || chainloader (0xff)
exit

:.isowinv
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix

#e.g. for ERDCommander
errorcheck off
# ignore error if not contiguous
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC%
errorcheck on
map %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
map --mem (bd)/%grub%/winvblock.img.gz (fd0)
map --mem (bd)/%grub%/winvblock.img.gz (fd1)
errorcheck off
if not exist CD map (hd1) (hd0)
if not exist CD map (hd0) (hd1)
errorcheck on
map --hook
root (0xff) || rootnoverify (0xff)
chainloader (0xff)/I386/setupldr.bin || chainloader (0xff)/minint/setupldr.bin || chainloader (0xff)/cmdcons/setupldr.bin || chainloader (0xff)/ntldr || chainloader (0xff)/bootmgr || chainloader (0xff)/BOOTMGR || chainloader (0xff)
exit

:.isofira01
errorcheck off
if not exist CD map (hd0) (hd1)
if not exist CD map (hd1) (hd0)

:.isofira
#for BartPE/Hirens Boot CD 13.1 using  firadisk
errorcheck off
# ignore error if not contiguous
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC%
map --mem (md)+4 (99) 
errorcheck on
map --mem (bd)/%grub%/firadisk.gz (fd0)
map --mem (bd)/%grub%/firadisk.gz (fd1)
map %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
map --hook
root (0xff) || rootnoverify (0xff)
write (99) [FiraDisk]\nStartOptions=cdrom,vmem=find:%~pnx1;\n\0 > nul
chainloader (0xff)
exit


##:.iso64memf01
:.isomemf01
errorcheck off
if not exist CD map (hd0) (hd1)
if not exist CD map (hd1) (hd0)

:.isomemfira
#for BartPE/Hirens Boot CD 13.1 using  firadisk
errorcheck off
# ignore error if not contiguous
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC%
map --mem (md)+4 (99) 
errorcheck on
map --mem (bd)/%grub%/firadisk.gz (fd0)
map --mem %ISOC% (0xff)
map --hook
write (99) [FiraDisk]\nStartOptions=cdrom,vmem=find:%~pnx1;\n\0 > nul
root (0xff) || rootnoverify (0xff)
chainloader (0xff)
exit

:.isomemwinv
#e.g. for UBCD4Win
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix
errorcheck off
# ignore error if not contiguous
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC%
errorcheck on
map --mem %ISOC% (0xff)
map --mem (bd)/%grub%/winvblock.img.gz (fd0)
map --mem (bd)/%grub%/winvblock.img.gz (fd1)
errorcheck off
if not exist CD map (hd1) (hd0)
if not exist CD map (hd0) (hd1)
errorcheck on
map --hook
root (0xff) || rootnoverify (0xff)
chainloader (0xff)/I386/setupldr.bin || chainloader (0xff)
exit

:.vhdmem
map --mem %ISOC% (hd0)
map --hook
root (hd0,0) || rootnoverify (hd0,0)
chainloader /bootmgr || chainloader /BOOTMGR || chainloader /ntldr || chainloader +1 || chainloader (hd0)+1
exit

:.vhdboot
map --heads=2 --sectors-per-track=18 --mem (md)0x800+4 (99)
map %ISOC% (hd0) > nul || map --mem %ISOC% (hd0)
map --hook
write (99) [FiraDisk]\nStartOptions=disk,vmem=find:%~pnx1,boot;\n\0
root (hd0,0) || rootnoverify (hd0,0)
chainloader /bootmgr || chainloader /BOOTMGR || chainloader /ntldr || chainloader +1 || chainloader (hd0)+1
exit

# xxxe0 extension - use --e820cycles if get black screen but HDD LED continues to flash and load Windows on certain systems

##:.iso64e0
:.isoe0
map --e820cycles=0
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix

if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC% || blocklist %ISOC% && call echo -e %emsg% && pause
map  %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
#map --mem (bd)/%grub%/firadisk.gz (fd0)
map --hook
root (0xff) || rootnoverify (0xff)
chainloader (0xff) || chainloader (0xff)/I386/setupldr.bin || chainloader (0xff)/minint/setupldr.bin || chainloader (0xff)/cmdcons/setupldr.bin || chainloader (0xff)/ntldr || chainloader (0xff)/bootmgr || chainloader (0xff)/BOOTMGR || chainloader --force (0xff)
exit

##:.iso64meme0
:.isomeme0
map --e820cycles=0
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix

if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC% || blocklist %ISOC% && call echo -e %emsg% && pause 
map --mem %ISOC% (0xff)
#map --mem (bd)/%grub%/firadisk.gz (fd0)
map --hook
root (0xff) || rootnoverify (0xff)
chainloader (0xff) || chainloader (0xff)/I386/setupldr.bin || chainloader (0xff)/minint/setupldr.bin || chainloader (0xff)/cmdcons/setupldr.bin || chainloader (0xff)/ntldr || chainloader (0xff)/bootmgr || chainloader (0xff)/BOOTMGR || chainloader --force (0xff)
exit

:.isowinvHe0
#e.g. for Hirens
map --e820cycles=0
errorcheck off
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC%
errorcheck on
map %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
map --mem (bd)/%grub%/winvblock.img.gz (fd0)
map --mem (bd)/%grub%/winvblock.img.gz (fd1)
#if not exist CD map (hd1) (hd0)
#if not exist CD map (hd0) (hd1)
map --hook
root (0xff) || rootnoverify (0xff)
chainloader (0xff)/I386/setupldr.bin || chainloader (0xff)/I386/setupldr.bin || chainloader (0xff)/ntldr || chainloader (0xff)/bootmgr || chainloader (0xff)/BOOTMGR || chainloader (0xff)
exit

:.isowinve0
#e.g. for ERDCommander
map --e820cycles=0
errorcheck off
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC%
errorcheck on
map %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
map --mem (bd)/%grub%/winvblock.img.gz (fd0)
map --mem (bd)/%grub%/winvblock.img.gz (fd1)
errorcheck off
if not exist CD map (hd1) (hd0)
if not exist CD map (hd0) (hd1)
errorcheck on
map --hook
root (0xff) || rootnoverify (0xff)
chainloader (0xff)/I386/setupldr.bin || chainloader (0xff)/minint/setupldr.bin || chainloader (0xff)/cmdcons/setupldr.bin || chainloader (0xff)/ntldr || chainloader (0xff)/bootmgr || chainloader (0xff)/BOOTMGR || chainloader (0xff)
exit

##:.iso64PE01
:.isoPE01
set PE01=1
goto :.isoPE

##:.iso64PE
:.isoPE
debug 1
# fill (rd) with 0's , 0x82d0 is rd-base mem address, Fn24 is memset - fill memory  <addr> <string> <size>
# OLD map (md)0x300+200 (rd) > nul ;; read 0x82d0  > nul ;; call Fn.24  %@retval% 0x20  102400  > nul
call Fn.24  0x60000 0x20  102400 > nul ;; map (md)0x300+200 (rd) > nul
#call :.contigfix
errorcheck off
# ignore error if not contiguous
if not exist CD partnew (%E2BDEV%,3) 0x0 %ISOC%
set AT=
if not exist CD if not exist ()/AutoUnattend.xml echo No \AutoUnattend.xml file found! && set AT=1
if not exist CD if not exist ()/Unattend.xml echo No \Unattend.xml file found! && set AT=1
if not exist CD dd if=(rd)+1 of=()/AutoUnattend.xml > nul
if not exist CD dd if=(bd)/_ISO/e2b/firadisk/aupe.xml of=()/AutoUnattend.xml > nul
if not exist CD dd if=(rd)+1 of=()/Unattend.xml > nul
if not exist CD dd if=(bd)/_ISO/e2b/firadisk/aupe.xml of=()/Unattend.xml > nul
# if extra USB Flash drive use Autounattend.xml on it - must have WINHELPER.USB file on it!
#findX /WINHELPER.USB && findX --set-root /WINHELPER.USB > nul &&  ls /AutoUnattend.xml > nul || echo USB DRIVE HAS WINHELPER.USB file but no AutoUnattend.xml! && pause
set WH=
errorcheck on
if exist (hd1,0)/WINHELPER.USB root (hd1,0) > nul && set WH=1
if "%WH%"=="" if exist (hd0,0)/WINHELPER.USB root (hd0,0) > nul && set WH=1
if "%WH%"=="" if exist (hd2,0)/WINHELPER.USB root (hd2,0) > nul && set WH=1
if "%WH%"=="" if exist (hd3,0)/WINHELPER.USB root (hd3,0) > nul && set WH=1
if "%WH%"=="" if exist (hd4,0)/WINHELPER.USB root (hd4,0) > nul && set WH=1
if "%WH%"=="" if exist (hd5,0)/WINHELPER.USB root (hd5,0) > nul && set WH=1
if "%WH%"=="" if exist (hd6,0)/WINHELPER.USB root (hd6,0) > nul && set WH=1
if "%WH%"=="" if exist (hd7,0)/WINHELPER.USB root (hd7,0) > nul && set WH=1
if "%WH%"=="" if exist (hd8,0)/WINHELPER.USB root (hd8,0) > nul && set WH=1
if "%WH%"=="" if exist (hd9,0)/WINHELPER.USB root (hd9,0) > nul && set WH=1
if "%WH%"=="" if exist AT pause ERROR: IF THIS IS A HARD DISK THEN A WINHELPER USB DRIVE IS REQUIRED.
if "%WH%"=="" if exist AT pause IF THIS IS A REMOVABLE DISK THEN \AutoUnattend.xml and \Unattend.xml IS REQUIRED.
if "%WH%"=="1" if not exist /AutoUnattend.xml echo USB DRIVE HAS WINHELPER.USB file but no AutoUnattend.xml! && pause
if "%WH%"=="1" if not exist /Unattend.xml echo USB DRIVE HAS WINHELPER.USB file but no Unattend.xml! && pause
if "%WH%"=="1" dd if=(rd)+1 of=()/AutoUnattend.xml > nul
if "%WH%"=="1" dd if=(bd)/_ISO/e2b/firadisk/aupe.xml of=()/AutoUnattend.xml > nul
if "%WH%"=="1" dd if=(rd)+1 of=()/Unattend.xml > nul
if "%WH%"=="1" dd if=(bd)/_ISO/e2b/firadisk/aupe.xml of=()/Unattend.xml > nul
set WH=
set AT=
root (bd) > nul
set ISOCP=%ISOC%
# get rid of leading () if any and device name
if "%ISOCP:~0,2%"=="()" set ISOCP=%ISOCP:~2,199%
if "%ISOCP:~0,7%"=="(hd0,0)" set ISOCP=%ISOCP:~7,199%
if "%ISOCP:~0,7%"=="(hd0,1)" set ISOCP=%ISOCP:~7,199%
if not exist CD dd if=(rd)+1 of=(bd)/_ISO/e2b/firadisk/ISONAME.CMD > nul
if not exist CD write (bd)/_ISO/e2b/firadisk/ISONAME.CMD SET \"MYISO=%ISOCP%\"\r\n > nul
if not exist CD cat --locate=/ --replace=\\ (bd)/_ISO/e2b/firadisk/ISONAME.CMD > nul

##map --mem (md)0x800+4 (99) > nul
map %ISOC% (0xff) > nul || map --mem %ISOC% (0xff)
errorcheck off
if "%PE01%"=="1" if not exist CD map (hd0) (hd1) > nul
if "%PE01%"=="1" if not exist CD map (hd1) (hd0) > nul
#map --mem (bd)/%grub%/winvblock.img.gz (fd0)
#map --mem (bd)/%grub%/winvblock.img.gz (fd1)
map --hook > nul
##write (99) [FiraDisk]\nStartOptions=cdrom,vmem=find:%~pnx1;\n\0 > nul
root (0xff) || rootnoverify (0xff)
chainloader (0xff)/bootmgr || chainloader (0xff)/BOOTMGR || chainloader (0xff)
#get rid of 'press any key' prompt
cat --locate=BOOTFIX.BIN --number=1 --replace=XXX (0xff)+0x1000
exit

:.isomacpup
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix
if not exist CD partnew (%E2BDEV%,3) 0x00 %ISOC% > nul || blocklist %ISOC% && call echo -e %emsg% && pause > nul
map %ISOC% (0xff) > nul
map --hook 
root (0xff)
# fix (cd) refences in menu.lst!
cat --replace=\x20\x20\x20\x20 --locate=(cd) (0xff)/boot/grub/menu.lst > nul && echo -e \n\n$[0x4]\nINFO: ISO file now permanently modified (if not read-only)\n      and (cd) references now removed from menu.lst file.\n\n && set /p A=Press ENTER... || clear
chainloader (0xff)
exit


##:.iso64pup
:.isopup
if "%E2BDEV%"=="" set E2BDEV=hd0 && pause E2BDEV forced to hd0!
# Change ISOC to defragged file if %ISOC% was fragmented
call :.contigfix
if not exist CD partnew (%E2BDEV%,3) 0x00 %ISOC% > nul || blocklist %ISOC% && call echo -e %emsg% && pause > nul
map %ISOC% (0xff) > nul
map --hook 
root (0xff)
set ERR=
if not exist /vmlinuz echo Cannot find vmlinuz in ISO! && set ERR=1
if not exist /initrd.gz echo Cannot find vmlinuz in ISO! && set ERR=1
if "%ERR%"=="1" echo ERROR: %ISOC% NOT A PUPPY LINUX ISO? && set MFOLDER=/_ISO/MAINMENU && set ERR= && call :waitexit
# usbflash usbhd usbcd ideflash satahd scsihd scsicd idehd idecd idezip
echo
echo $[0x0e] Select Type of Boot Device
echo $[0x0e] ==========================
echo $[0x0e] 0 = Auto (may not always work)
echo $[0x0e] 1 = USB Flash Drive
echo $[0x0e] 2 = USB Hard Disk
echo $[0x0e] 3 = SATA Hard Disk (e.g. Testing in VBox)
echo $[0x0e] 4 = IDE  Hard Disk (e.g. Testing in QEMU or VBox)
echo $[0x0e] 5 = SCSI Hard Disk (e.g. Testing in VBox)
echo
set pm=
set /p ask=Enter type (0-5) : 
if "%ask%"=="0" set pm=pmedia=
if "%ask%"=="1" set pm=pmedia=usbflash
if "%ask%"=="2" set pm=pmedia=usbhd
if "%ask%"=="3" set pm=pmedia=satahd
if "%ask%"=="4" set pm=pmedia=idehd
if "%ask%"=="5" set pm=pmedia=scsihd
echo
errorcheck off
if "%pm%"=="" map --unhook > nul && map --unmap=0xff > nul && root %_BOOT% > nul && clear && echo BAD ENTRY! && echo && pause --wait=3 > nul
if not "%pm%"=="" echo Booting using %pm% vga=ask fix=fsck psavemark=1 && pause --wait=2 > nul
echo
# must run on one line or grub4dos hangs!
if not "%pm%"=="" kernel /vmlinuz %pm% vga=ask fix=fsck psavemark=1 && initrd /initrd.gz && boot
set ask=
set pm=
exit


:.isoWB
##:.iso64WB
# This .mnu file allows you to have multiple WinBuilder ISOs on one E2B drive

# Place WB ISO in \_ISO\MAINMENU folder (or \_ISO\WINPE) 
# Copy the WinBuilder .INI file to the root of the USB drive - e.g. \Win7PESE.ini
#   - add extra lines of spaces if needed to make file 1K bytes or more
# Make a .WB file of same filename as the ISO - e.g. WinSS_x86.WB - in WB folder below ISO folder (e.g. \_ISO\MAINMENU\WB)
# Contents of .WB  (IniName is case sensitive!):
#      !BAT
#      set IniName=Win7PESE.ini
# 
# Make sure that the name of the INI file in the root of the E2B drive is matches what is in the .WB file
# If you see a yellow triangle on the WB Desktop - you have done something wrong!

# Typical File arrangement
#  \_ISO\MAINMENU\\WinSS_x86.isoWB
#  \_ISO\MAINMENU\WB\WinSS_x86.WB
#  \Win7PESE.ini    <--- DO NOT CHANGE THIS FILENAME
set ISOFN=%~n1
# Line above must contain WB ISO filename (no file extension)
set ERR=
if not exist %~p1WB/%ISOFN%.WB echo -e ERROR: No %ISOFN%.WB file found in %~p1WB/ folder!\nPlease check instructions for using .ISOWB file extension. && set ERR=1 && set /p A=Press ENTER...
call %~p1WB/%ISOFN%.WB
# We now have INI name
if not exist IniName if "%ERR%"=="" echo ERROR: No 'set IniName=' line in %~p1WB/%ISOFN%.WB file! && echo -e Example:\n!BAT\nset IniName=Win7PESE.ini\n\nPlease check contents and case of variable IniName!  && set ERR=1
if not exist /%IniName% if "%ERR%"=="" set ERR=1 && set /p A=ERROR: No %IniName% .INI file found in root of drive!
# fill (rd) with 0's , 0x82d0 is rd-base mem address, Fn24 is memset - fill memory  <addr> <string> <size>
#OLD map (md)0x300+200 (rd) > nul ;; read 0x82d0  > nul ;; call Fn.24  %@retval% 0x20  102400  > nul
call Fn.24  0x60000 0x20  102400 > nul ;; map (md)0x300+200 (rd) > nul
dd if=(rd)+1 of=()/%IniName%
#[IsoInfo]
#IsoName=/_ISO/MAINMENU/MNU/WinSS_x86.ISO
echo -e Writing:\n[IsoInfo]\nIsoName=%~p1%ISOFN%.ISOWB\nto /%IniName%
echo [IsoInfo] > /%IniName%
echo -e IsoName=%~p1%ISOFN%.ISOWB >> /%IniName%
cat --locate=%ISOFN:~10,10%.ISOWB /%IniName% > nul || set ERR=1 && set /p A=ERROR: /%IniName% may be too small (should be 1K)
if "%ERR%"=="1" set MFOLDER=/_ISO/MAINMENU && configfile (md)0xa000+0x50
goto :.iso01





:.isoask
clear
echo
echo I  = .iso        - boot as typical ISO (e.g. linux, etc.)
echo I1 = .iso01      - boot as .iso but swap hd0 and hd1
echo IF = .isoforce   - force an ISO to boot even if grub4dos thinks it is unbootable (e.g. CentOs)
echo MI = .isomem     - load ISO into memory and boot
echo F  = .isofira    - boot with firadisk drivers on a virtual floppy + mount ISO (e.g. Strelec)
echo F1 = .isofira01  - boot as .isofira plus swap hd0&1 (ERD MSDart5/XP/Strelec)
echo MF = .isomemFira - load ISO into memory with FiraDisk driver on a virtual floppy disk
echo FM = .isomemF01  - load ISO into memory with FiraDisk driver on a virtual floppy disk + hd0&1 swap
echo W  = .isoWinv    - boot ERD commander type ISO with WinVBlock + hd0&1 swap
echo MW = .isoMemWinv - load ISO into memory + WinVBlock driver on virtual floppy disk + hd0&1 swap
echo H  = .isoWinvH   - boots with WinVBlock (no hdd swap) (for Hirens ISOs with extracted \HBCD folder)
echo HW = .isoHW      - combines .isowinvh with .isope (for Hirens\DLC with XP+Win7/8+Removable E2B)
echo IZ = .isogz      - boot ISO with FiraDisk.gz floppy (without using partnew)
echo ID = .isoDOS     - boot a DOS-based ISO, drive B: will contain the contents of the CD
echo I0 = .isoDOS01   - as .isoDOS but swaps hd0 with hd1 first
echo IN = .isonousb   - load a DOS-based ISO into memory, hide the USB drive and boot
echo IP = .isopup     - for Puppy Linux and slacko ISOs (with Save enabled)
echo IM = .isopupmac  - for Macpup ISOs - modifies ISO file to remove (cd) references
echo
echo EI = .isoe0      - boot a Windows ISO that normally fails with blank screen on a bad system
echo EM = .isomeme0   - load into memory and boot ISO that fails with blank screen on a bad system
echo EW = .isoWinve0  - boot XP such as ERD Commander that gives blank screen on a bad system
echo EH = .isoWinvHe0 - boot a Hirens ISO that gives blank screen on a bad system
echo
echo BW = .isowin     - use for Windows ISOs that are missing the boot loader (loads ntldr/bootmgr)
echo BL = .isolinux   - use for linux ISOs that are missing the boot loader (loads isolinux.bin)
echo BG = .isogrub    - use for grub or grub4dos ISOs that are missing the boot loader (loads grldr)
echo PE = .isoPE      - use for non-XP WinPE ISOs (ISO=Y: when wpeinit runs during WinPE startup)
echo P1 = .isoPE01    - use for WinPE and some Windows Install ISOs
echo PC = .isoPECD    - as .isoPE but use for multiboot ISOs which also boot to WinPE
echo PD = .isoPE01CD  - as .isoPE01 but use for multiboot ISOs which also boot to WinPE

echo
set /u /p ask=Choose an option : 
echo
if "%ask%"=="I"  call :.isodd %1
if "%ask%"=="I1" call :.iso01 %1
if "%ask%"=="IF" call :.isoforce %1
if "%ask%"=="MI" call :.isomem %1
if "%ask%"=="F"  call :.isofira %1
if "%ask%"=="F1" call :.isofira01 %1
if "%ask%"=="MF" call :.isomemFira %1
if "%ask%"=="FM" call :.isomemF01 %1
if "%ask%"=="W"  call :.isowinv %1
if "%ask%"=="MW" call :.isomemwinv %1
if "%ask%"=="H"  call :.isowinvH %1
if "%ask%"=="HW" call :.isoHW %1
if "%ask%"=="IZ" call :.isogz %1
if "%ask%"=="ID" call :.isoDOS %1
if "%ask%"=="I0" call :.isoDOS01 %1
if "%ask%"=="IP" call :.isopup %1
if "%ask%"=="IM" call :.isomacpup %1

if "%ask%"=="EI" call :.isoe0 %1
if "%ask%"=="EM" call :.isomeme0 %1
if "%ask%"=="EW" call :.isoWinVe0 %1
if "%ask%"=="EH" call :.isoWinvHe0 %1

if "%ask%"=="BW" call :.isowin %1
if "%ask%"=="BL" call :.isolinux %1
if "%ask%"=="BG" call :.isogrub %1
if "%ask%"=="PE" call :.isoPE %1
if "%ask%"=="P1" call :.isoPE01 %1
if "%ask%"=="IN" call :.isonousb %1
if "%ask%"=="PC" call :.isoPECD %1
if "%ask%"=="PD" call :.isoPE01CD %1

exit


# ------------- PARTITION IMAGE BOOTING ----------------

:.imgPTNLBA23
set LEAVE23=1
set LEAVE3=
set DOLBA=1
set MAKEACT=
goto :.imgPTNxxx

:.imgPTNaLBA23
:.imgPTNa23LBA
:.imgPTNLBAa23
:.imgPTNLBA23a
:.imgPTN23LBAa
:.imgPTN23aLBA
set LEAVE3=
set LEAVE23=1
set DOLBA=1
set MAKEACT=1
goto :.imgPTNxxx

:.imgPTN23
set LEAVE23=1
set LEAVE3=
set DOLBA=
set MAKEACT=
goto :.imgPTNxxx


:.imgPTNA5
:.imgPTNA6
:.imgPTNA9
:.imgPTN
:.imgEFI
:.imgPTNaLBA
:.imgPTNLBAa
set LEAVE23=
set LEAVE3=
set DOLBA=1
set MAKEACT=1
goto :.imgPTNxxx

:.imgPTNlba
set MAKEACT=
set LEAVE23=
set LEAVE3=
set DOLBA=1
goto :.imgPTNxxx

:.imgPTN23a
:.imgPTNa23
set DOLBA=
set LEAVE3=
set LEAVE23=1
set MAKEACT=1
goto :.imgPTNxxx

:.imgPTNA
set DOLBA=
set LEAVE23=
set LEAVE3=
set MAKEACT=1
goto :.imgPTNxxx

:.imgPTNna
:.imgEFIna
set MAKEACT=
set DOLBA=
set LEAVE23=
set LEAVE3=

:.imgPTNxxx
set IMG=%1
if not exist %IMG% echo -e %IMG% does not exist! && call :waitexit
# check hd0 is the E2B drive

if exist CD set /p A=Cannot use .imgPTN on a CD (or WP)! 
if exist CD exit

debug off
#enable parttype output
# make empty table entry in 3rd position in ptn table
parttype (%E2BDEV%,2) ;; set check=%@retval%
if exist %~dpn1 if not %check%==0 echo ERROR: Partition 3 is in use - cannot use auxiliary file %~dpn1 && call :waitexit
set check=

if not exist (%E2BDEV%,0)/_ISO/e2b/grub/E2B.cfg if not exist  (%E2BDEV%,1)/_ISO/e2b/grub/E2B.cfg echo Sorry - E2B needs to be on Disk0-Partition0 or 1! && call :waitexit

# check if sector 30 is unused (has no code)
set GUD=
cat --hex (%E2BDEV%)30+1 > (md)0x3200+5
cat --locate=" 00" (md)0x3200+5 > nul
if "%@retval%"=="512" set GUD=1
cat --locate=" FF" (md)0x3200+5 > nul
if "%@retval%"=="512" set GUD=1 
cat --locate=" E5" (md)0x3200+5 > nul
if "%@retval%"=="512" set GUD=1
# check if already has old MBR from previous run
cat --locate=\x55\xAA --skip=0x1fe (%E2BDEV%)30+1  > nul && set GUD=1
# if GUD=1 then we can overwrite LBA 30
if not "%GUD%"=="1" echo PROBLEM: Sector at LBA30 appears to contain code - please reformat using RMPrepUSB && call :waitexit
dd if=(%E2BDEV%)0+1 of=(%E2BDEV%)30+1 > nul || echo -e $[0x04]Write Error backing up E2B MBR to LBA30!\nIf using Virtual Box, please use DavidB's VMUB utility for full write access. && call :waitexit


# check if sector 60 is unused (has no code) or is MBR
set GUD=
cat --hex (%E2BDEV%)60+1 > (md)0x3200+5
cat --locate=" 00" (md)0x3200+5 > nul
if "%@retval%"=="512" set GUD=1
cat --locate=" FF" (md)0x3200+5 > nul
if "%@retval%"=="512" set GUD=1 
cat --locate=" E5" (md)0x3200+5 > nul
if "%@retval%"=="512" set GUD=1
# check if already has old MBR from previous run
cat --locate=\x55\xAA --skip=0x1fe (%E2BDEV%)60+1  > nul && set GUD=1
# if GUD=1 then we can overwrite LBA 60
if "%GUD%"=="1" dd if=(%E2BDEV%)0+1 of=(%E2BDEV%)60+1 > nul

# MBR backed up to primary location of 30 and also 60 as reserve

# test it first
debug 0
echo %redirp%
if exist NOTCONTIG call echo -e %emsg% && partnew (%E2BDEV%,3) 0 0 0 0 > nul && call :waitexit
partnew (%E2BDEV%,3) 0x0 %IMG% %redir% || call echo -e %emsg% && partnew (%E2BDEV%,3) 0 0 0 0 > nul && blocklist %IMG% && call :waitexit
if not exist (%E2BDEV%,3)/menu.lst echo -e ERROR: %IMG% has no menu.lst file! && partnew (%E2BDEV%,3) 0 0 0 0 > nul && call :waitexit
if not exist (%E2BDEV%,3)/grldr echo -e ERROR: %IMG% has no grldr file! && partnew (%E2BDEV%,3) 0 0 0 0 > nul && call :waitexit


#required due to partnew bug in 0.4.6a
if not exist %~dpn1 goto :nn1
blocklist %~dpn1 > (md)0x200+1
cat --locate=+ --number=1 (md)0x200+1 > nul
cat --locate=, --skip=%?% (md)0x200+1 > nul && echo -e $[0xe4]\nERROR: %~pn1 IS NOT CONTIGUOUS! && debug -1 && call :waitexit
# get start address of file
set r=
cat --locate=+ --replace="               " --number=1 (md)0x200+1 > nul
cat --locate=) (md)0x200+1 > nul
set /A r=%?%+1 > nul
cat --skip=%r% (md)0x200+1 | set /A FN= > nul
set r=
:nn1


set GUDMBR=
cat --locate="Missing MBR-help" (%E2BDEV%)0+1 > nul && set GUDMBR=1
#grub4dos 0.4.6a BootIce MBR
cat --locate="Missing helper" (%E2BDEV%)0+1 > nul && set GUDMBR=1
cat --locate="FLBT" (%E2BDEV%)0+1 > nul && set GUDMBR=1 && echo -e $[0x0c]\n\nWARNING: FlashBoot MBR detected.\n\nThis drive will not boot in MBR Mode once you switch partitions!\nYou must use \\e2b\\RestoreE2B (run as admin).cmd to make it bootable again.\n && pause Press ENTER to continue...
if not "%GUDMBR%"=="1" echo -e ERROR: Please install Grub4dos to the MBR of this drive using RMPrepUSB! && partnew (%E2BDEV%,3) 0 0 0 0 > nul && call :waitexit
set GUDMBR=
set GUD=

cat --locate="+1 " (%E2BDEV%,3)/menu.lst > nul || echo -e ERROR: %IMG% has no menu entry to return back to E2B! && partnew (%E2BDEV%,3) 0 0 0 0 > nul && call :waitexit
cat --locate="dd if=(hd0)" (%E2BDEV%,3)/menu.lst > nul || echo -e ERROR: %IMG% has no menu entry to return back to E2B! && partnew (%E2BDEV%,3) 0 0 0 0 > nul && call :waitexit
debug off

clear
echo %redirp%
echo -e (%E2BDEV%,0) $[0x0e] %~nx1 %redirp%
if exist %~dpn1 echo -e (%E2BDEV%,2) $[0x0e] %~n1 %redirp%
echo %redirp%
call getstr.g4b $$STRbpt1 ;; call echo -e %STR% %redir%
call getstr.g4b $$STRbpt2 ;; call echo -e %STR% %redir%
echo %redirp%
set EFI=
if exist (%E2BDEV%,3)/EFI/boot/bootia32.efi   echo -e $[0x0e]INFORMATION: x86 32-bit UEFI boot file '\\EFI\\boot\\bootia32.efi' is present %redir% && set EFI=1
if exist (%E2BDEV%,3)/EFI/boot/bootx64.efi    echo -e $[0x0e]INFORMATION: x86 64-bit UEFI boot file '\\EFI\\boot\\bootx64.efi' is present %redir% && set EFI=1
if exist (%E2BDEV%,3)/EFI/boot/bootia64.efi   echo -e $[0x0e]INFORMATION: ITANIUM 64-bit UEFI boot file '\\EFI\\boot\\bootia64.efi' is present %redir% && set EFI=1
if exist (%E2BDEV%,3)/EFI/boot/bootARM.efi    echo -e $[0x0e]INFORMATION: ARM 32-bit UEFI boot file '\\EFI\\boot\\bootARM.efi' is present %redir% && set EFI=1
if exist (%E2BDEV%,3)/EFI/boot/bootAA64.efi   echo -e $[0x0e]INFORMATION: ARM 64-bit UEFI boot file '\\EFI\\boot\\bootAA64.efi' is present %redir% && set EFI=1
if not exist EFI echo -e $[0x0e]INFORMATION:  *** NO UEFI BOOT FILES IN FIRST PARTITION *** %redir%

if exist FN if %FI%>=%FN% echo -e $[0x74]\nWARNING: %~nx1 is located before %~n1 on the disk.\nFix using MOVE_IMGPTN or you may not get a UEFI boot option. %redir%
set FI=
set FN=
set EFI=
call getstr.g4b $$STRbpt3 ;; call echo -e %STR% %redir%

echo  %redir%
set COMMA=
set OP=
if not "%MAKEACT%%%DOLBA%%%LEAVE23%%%LEAVE3%"=="" set OP=$[0107]\x20   (OPTIONS: 
if "%MAKEACT%"=="1" set OP=%OP%a=Make-Active && set COMMA=,
if "%DOLBA%"=="1" set OP=%OP%%%COMMA% LBA=Adjust-LBA && set COMMA=,
if "%LEAVE23%"=="1" set OP=%OP%%%COMMA% 23=Leave-Ptn2&3 && set COMMA=,
if not "%LEAVE23%"=="1" if "%LEAVE3%"=="1" set OP=%OP%%%COMMA% 3=Leave-Ptn3
if not "%OP%"=="" echo -e %OP%) %redir%
set COMMA=
set OP=
echo  %redir%

#echo -e $[0x0c]WARNING: THIS E2B DRIVE'S PARTITION TABLE IS ABOUT TO BE OVERWRITTEN!
#echo -e $[0x0c]    THERE IS A SMALL RISK OF LOSING ALL FILES ON THE E2B DRIVE.
#echo -e $[0x0c]    A BACKUP OF THE MBR HAS BEEN MADE.
#echo -e $[0x0c]
#echo -e $[0x0c]    You can restore the original E2B partitions from Windows using the
#echo -e $[0x0c]    '\\e2b\\RestoreE2B (run as admin).cmd' script on the USB drive.
#echo -e $[0x0c]    (see www.easy2boot.com for details)
#echo
#echo To boot using UEFI, reboot and select the UEFI:xxxx boot option from your UEFI boot menu. 
#echo To switch back to Easy2Boot, boot as non-UEFI (Legacy or CSM Mode)
#echo and select the Easy2Boot menu option.
#echo To boot using UEFI, reboot and select the UEFI:xxxx boot option from your UEFI boot menu.
#echo To switch back to Easy2Boot, either:
#echo     - boot as non-UEFI (Legacy or CSM Mode) and select the 'Easy2Boot' menu option
#echo     - or run the '\\e2b\\RestoreE2B (run as admin)' script on the USB drive.

# clear ptn 4 for now in case user quits E2B
partnew (%E2BDEV%,3) 0 0 0 0 > nul

if "%AUTOCSM%"=="1" goto :NUKE
if exist redirp goto :NUKE
echo  %redir%
set ask=
set STR=
call getstr.g4b $$STRbpt4
#if STRbpt4 is empty, then don't ask question, just do it!
if "%STR%"=="" goto :NUKE
set /u /p ask=%STR%
#OK to replace the E2B partitions ([Y]/N) : 
if /i not "%ask%"=="N" goto :NUKE
echo %redirp%
#tidy up
set ask=
set STR=
set DOLBA=
set LEAVE3=
set LEAVE23=
set MAKEACT=
set IMG=
set JE=
set emsg=
set ISOC=
partnew (%E2BDEV%,3) 0 0 0 0 > nul
errorcheck off
exit

#configfile (md)0xa000+0x50

:NUKE
#clear
debug 1
echo %redir%
set ask=
set STR=
# restore image in 4th partition
partnew (%E2BDEV%,3) 0x0 %IMG% > nul || call echo -e %emsg% && partnew (%E2BDEV%,3) 0 0 0 0 > nul && blocklist %IMG% && call :waitexit

# if we have a auxilliary 2nd ptn (no extension) then put that in (%E2BDEV%,2)
set AUX=
if exist %~dpn1 set AUX=0 || goto :skipaux

# check for BSD images
cat --locate=\xA5 --length=1 --skip=0x1f2 %~dpn1 > nul && set AUX=A5
cat --locate=\xA5 --length=1 --skip=0x1e2 %~dpn1 > nul && set AUX=A5
cat --locate=\xA5 --length=1 --skip=0x1d2 %~dpn1 > nul && set AUX=A5
cat --locate=\xA5 --length=1 --skip=0x1c2 %~dpn1 > nul && set AUX=A5
errorcheck on
set LEAVE3=1
set T=%ISOC% && set ISOC=%~dpn1
partnew (%E2BDEV%,2) 0x%AUX% %~dpn1 > nul || call echo -e %emsg% && partnew (%E2BDEV%,3) 0 0 0 0 > nul && blocklist %~dpn1 && call :waitexit
set ISOC=%T% && set T=
echo %redir% && echo -e $[0106](%E2BDEV%,2) [%AUX%] %~n1\n %redir%
errorcheck off
set AUX=
:skipaux


# first get MBR into two areas of memory
dd if=(%E2BDEV%) of=(md)0x3200+1 count=1 > nul
dd if=(%E2BDEV%) of=(md)0x3100+1 count=1 > nul

#check we have two ptns
set /A n=*0x6401f2 & 0xFF > nul
if "%n%"=="0x0" echo ERROR: Partition #4 is empty! && call :waitexit
set n=
# EFI partition is in table entry 4, copy to table entry 1 and destroy table entries 4, 3 and 2

#Now overwrite 2nd copy with tables from 1st copy but change the order...
set /A m=*0x6401ee > nul
write     0x6201be %m% > nul
set /A m=*0x6401f2 > nul
write     0x6201c2 %m% > nul
set /A m=*0x6401f6 > nul
write     0x6201c6 %m% > nul
set /A m=*0x6401fa > nul
write     0x6201ca %m% > nul

# write new disk signature with start LBA for unique disk ID (set to start LBA of the .imgPTN file for pseudo-random value)
set /A m=*0x6401f6 > nul
write    0x6201b8 %m% > nul

# check if Type 21 ptn present - if so and .imgPTN or .imgPTNAUTO used then leave ptn 2 in partition table
parttype (%E2BDEV%,1) > nul
set /A pp2=%@retval% > nul
set p2=
if /i "%JE%"==".IMGPTN" set /A p2=%pp2% > nul
if /i "%JE%"==".IMGPTNAUTO" set /A p2=%pp2% > nul
# if extension is not .imgPTN then don't leave ptn 2 in
# if 2nd image file, then don't keep type 21h file
if /i "%JE%"==".IMGPTN" if exist %~dpn1 set p2=
if /i "%JE%"==".IMGPTNAUTO" if exist %~dpn1 set p2=
set pp2=

# BLANK THE PTN ENTRIES
set m=0x000000 > nul
# hd0,1
if not "%LEAVE2%"=="1" if not "%LEAVE23%"=="1" if not "%p2%"=="0x21" write     0x6201ce %m% > nul
if not "%LEAVE2%"=="1" if not "%LEAVE23%"=="1" if not "%p2%"=="0x21" write     0x6201d2 %m% > nul
if not "%LEAVE2%"=="1" if not "%LEAVE23%"=="1" if not "%p2%"=="0x21" write     0x6201d6 %m% > nul
if not "%LEAVE2%"=="1" if not "%LEAVE23%"=="1" if not "%p2%"=="0x21" write     0x6201da %m% > nul
# hd0,2
if not "%LEAVE3%"=="1" if not "%LEAVE23%"=="1" write     0x6201de %m% > nul
if not "%LEAVE3%"=="1" if not "%LEAVE23%"=="1" write     0x6201e2 %m% > nul
if not "%LEAVE3%"=="1" if not "%LEAVE23%"=="1" write     0x6201e6 %m% > nul
if not "%LEAVE3%"=="1" if not "%LEAVE23%"=="1" write     0x6201ea %m% > nul
# hd0,3
write     0x6201ee %m% > nul
write     0x6201f2 %m% > nul
write     0x6201f6 %m% > nul
write     0x6201fa %m% > nul


# If DOLBA=1 then overwrite CHS END entry with maximum so we get 64x255 geometry
if not "%DOLBA%"=="1" goto :skplba
read 0x6201c2 > nul ;; set /A lsb=%@retval%&0xff > nul
set /A B=0xFFFFFE00|%lsb% > nul
write 0x6201c2 %B% > nul
#set start cyl to max LBA too
read 0x6201be > nul ;; set /A lsb=%@retval%&0xff > nul
set /A B=0xFFFFFE00|%lsb% > nul
write 0x6201be %B% > nul
:skplba


#overwrite whole ptn table with new one
dd if=(md)0x3100+1 of=(%E2BDEV%) count=1 > nul || echo ERROR UPDATING MBR! && dd of=(%E2BDEV%)0+1 if=(%E2BDEV%)30+1 > nul && call :waitexit

#make partition active if .imgPTNA used
if "%MAKEACT%"=="1" makeactive (%E2BDEV%,0) > nul
# Backup new MBR so we can restore the imgptn partition if needed
dd if=(%E2BDEV%) of=(%E2BDEV%)31+1 count=1 > nul
echo -e $[0x0e](%E2BDEV%,0)      %~nx1 %redir%
errorcheck off
# suppress 'Filesystem type is FAT, partition type 0x0C' message
root (%E2BDEV%,0) > nul
chainloader /grldr > nul
#boot
#echo ...
# delay for 2 seconds
#set /p:2 ask=... > nul
exit

# ---- make contiguous - user must add \_ISO\CONTIG.ISO file and make it contiguous

:.contigfix
debug 1

#if CD or write-protected, try isoboot
if exist CD goto :.isoerr

# if target is already contiguous then go back to calling code
if not exist NOTCONTIG goto :.isoA
# make contiguous by copying to a contiguous file
if not exist ()/_ISO/CONTIG.ISO goto :.isoerr
# check if CONTIG.ISO is contiguous

#required due to partnew bug in 0.4.6a
blocklist ()/_ISO/CONTIG.ISO > (md)0x200+1
cat --locate=+ --number=1 (md)0x200+1 > nul
cat --locate=, --skip=%?% (md)0x200+1 > nul && echo -e $[0xe4]\nERROR: /_ISO/CONTIG.ISO IS NOT CONTIGUOUS! && debug -1 && set /p:2 A= || goto :.isoerr

map ()/_ISO/CONTIG.ISO (0xff) > nul || echo -e $[0xe4]\nERROR: /_ISO/CONTIG.ISO IS NOT CONTIGUOUS! && set /p:2 A= || goto :.isoerr
cat --length=0 ()/_ISO/CONTIG.ISO > nul
set /a CL=*0x8290 > nul
set /a CL=%CL% + 1 > nul
cat --length=0 %ISOC% > nul
set /a IL=*0x8290 > nul
echo -e FILE IS NOT CONTIGUOUS - attempting to copy to /_ISO/CONTIG.ISO...
echo -e FILESIZES: %ISOC%=%IL%    CONTIG.ISO=%CL%
# Fix for numbers > 2GB being -ve when using <=  - divide by 10
set CL=%CL:~0,-1% > nul
set IL=%IL:~0,-1% > nul
if %CL%<=%IL% echo && echo -e $[0xe4]ERROR: /_ISO/CONTIG.ISO is smaller than %ISOC%\nCannot copy!\nTip: Replace CONTIG.ISO with a larger file (any contents).\n && set /p A=Press ENTER to try ISOBOOT (for linux ISOs only)... || goto .isoerr
echo $[0x0e]Copying %ISOC% to /_ISO/CONTIG.ISO to make it contiguous...
debug 1
dd if=%ISOC% of=()/_ISO/CONTIG.ISO buf=40M buflen=64M || set /p A=dd error copying to /_ISO/CONTIG.ISO file
set ISOC=()/_ISO/CONTIG.ISO
:.isoA
set CL=
set IL=
debug 0
goto :eof

:.isoerr
set CL=
set IL=
# attempt to isoboot
call /%grub%/isoboot.g4b
debug 0
root (%_BOOT%) || root (bd)
#configfile (md)0xa000+0x50 || configfile (md)0x3000+0x50
goto :eof

:waitexit
set A=:%~1
if "%1"=="" set A=
set STR=
call getstr.g4b $$STRPKEY ;; set emsg=%STR%
if not exist STR set STR=Press [ENTER] to continue...
echo $[0104]%STR%
set /p A=
configfile (md)0xA000+0x50
exit

